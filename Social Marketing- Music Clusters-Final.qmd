---
title: "CSA Social Marketing: Music Clusters - Selected version"
format: html
self-contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
```

```{r}

# Load packages
pacman::p_load("tidyverse", 
  "ggcorrplot", #correlation matrix
  "readxl", 
  "ggplot2", 
  "factoextra", #K means, dendogram
  'ggrepel', #cleaner plot labels
  "patchwork")
```

```{r}
dat = read_csv('Music-Data.csv') %>% 
    drop_na()


# remove non-numeric columns, but keep ResponseId separately
id_vec <- dat$ResponseId

# filter out respondents with zero variance
dat_num <- dat %>% select(-ResponseId)
row_sds <- apply(dat_num, 1, sd, na.rm = TRUE)
cdat_num_nozerovar <- dat_num[row_sds > 0, ]
id_vec   <- id_vec[row_sds > 0]  # keep IDs aligned

# Also remove nonzero from cdat
cdat_nozerovar <- dat[row_sds > 0, ]

# transpose, items as rows and people as columns
cdat_t <- as.data.frame(t(cdat_num_nozerovar))

# name columns as people, rows as items
colnames(cdat_t) <- id_vec
rownames(cdat_t) <- colnames(cdat_num_nozerovar)

# Create person-level correlation matrix
corrmat <- cdat_t %>% 
    cor() 
```

```{r}
k = 4

# Using alternative packages that can handle larger matrices better
library(ClusterR)
set.seed(10)
k_means4 <- MiniBatchKmeans(corrmat, clusters = k, batch_size = 500, num_init = 10)
clusters = predict_KMeans(corrmat, k_means4$centroids)

```

```{r}
library(irlba)
# Instead of prcomp(corrmat, scale.=TRUE)
# ask only for first 10 components (enough for 2D plot + stability checks)
set.seed(10)
pcs_fast <- prcomp_irlba(corrmat, n = 10, scale. = TRUE)
```

```{r}
scores <- as.data.frame(pcs_fast$x[, 1:10])    # respondent positions
scores$cluster <- factor(clusters)    # add cluster assignment

# correlate PCs with original items
cor_with_items <- cor(scores[,1:10], cdat_num_nozerovar, use = "pairwise.complete.obs")
cor_with_items <- as.data.frame(t(cor_with_items))  
cor_with_items$Variable <- rownames(cor_with_items)

arrow_scale <- 120 # to scale the arrows for readability
clusternames = levels(scores$cluster)

# Need to find convex hull of each cluster
hull_points2 <- scores %>%
  group_by(cluster) %>%
  slice(chull(PC1, PC2))

# cluster plot with arrows and labels
ggplot(scores, aes(x = PC1, y = PC2, color = cluster, shape = cluster)) +
  # geom_point(alpha = 0.4) +
  theme_classic() +
  ggtitle("MiniBatchKmeans Clusters (PCA projection)") +
  geom_polygon(data = hull_points2, aes(fill = cluster), 
               alpha = 0.15) +
  theme_classic() +
  geom_segment(data = cor_with_items,
               aes(x = 0, y = 0, xend = PC1 * arrow_scale, yend = PC2 * arrow_scale),
               arrow = arrow(length = unit(0.2,"cm")),
               inherit.aes = FALSE, color = "grey40") +
  ggrepel::geom_text_repel(data = cor_with_items,
               aes(x = PC1 * (arrow_scale + 2),
                   y = PC2 * (arrow_scale + 2),
                   label = Variable),
               inherit.aes = FALSE,
               size = 6, color = "black", max.overlaps = 100) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey40") + 
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
  scale_color_discrete(labels = clusternames, name = "Cluster") +
  scale_shape_discrete(labels = clusternames, name = "Cluster") +
  guides(fill = "none") +
  ggtitle('') + # Clean theme
  theme_minimal(base_size = 14) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    axis.ticks = element_blank(),
    panel.grid = element_blank(),
    legend.position = "none"
    # legend.direction = "horizontal",
    # legend.title = element_text(size = 14, face = "bold"),
    # legend.text  = element_text(size = 12)
  )
```

### Cluster interpretation & Labels

- 1: Mainstream Western Pop/Rock
- 2: Niche/Eclectic/Experimental
- 3: Mainstream Afro-diasporic
- 4: Non-Mainstream Rock (Headbangers)


```{r}
# Save cluster labels
cluster_labels <- c(
  "1" = "Mainstream Pop/Rock",
  "2" = "Eclectic",
  "3" = "Mainstream Afro-diasporic",
  "4" = "Non-Mainstream Rock"
)

scores %>% 
  mutate(ResponseId = id_vec,
         Genre_Cluster = cluster_labels[cluster]) %>%
  select(ResponseId, cluster, Genre_Cluster) %>% 
  write_csv("music_genre_cluster_labels.csv")
```